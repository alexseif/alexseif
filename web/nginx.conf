# Use the front controller as index file. It serves as a fallback solution when
# every other rewrite/redirect fails (e.g. in an aliased environment without
# mod_rewrite). Additionally, this reduces the matching process for the
# start page (path "/") because otherwise Apache will apply the rewriting rules
# to each configured DirectoryIndex file (e.g. index.php, index.html, index.pl).
index app.php;

# Disabling MultiViews prevents unwanted negotiation, e.g. "/app" should not resolve
# to the front controller "/app.php" but be rewritten to "/app.php/app".
location / {
    try_files $uri $uri/ /app.php$is_args$args;
}

# If the requested filename exists, simply serve it.
# We only want to let Nginx serve files and not directories.
location ~ ^/app\.php(/|$) {
    try_files $uri =404;
    fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;
    fastcgi_split_path_info ^(.+\.php)(/.*)$;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    fastcgi_param PATH_INFO $fastcgi_path_info;
    internal;
}

# Sets the HTTP_AUTHORIZATION header removed by Apache
location ~* ^/ {
    fastcgi_param HTTP_AUTHORIZATION $http_authorization;
}

# Redirect to URI without front controller to prevent duplicate content
# (with and without `/app.php`). Only do this redirect on the initial
# rewrite by Nginx and not on subsequent cycles. Otherwise we would get an
# endless redirect loop (request -> rewrite to front controller ->
# redirect -> request -> ...).
if ($request_uri ~* "^/app\.php(/|$)") {
    return 301 $scheme://$server_name$request_uri;
}

# When mod_rewrite is not available, we instruct a temporary redirect of
# the start page to the front controller explicitly so that the website
# and the generated links can still be used.
location / {
    rewrite ^/$ /app.php/ redirect;
}
